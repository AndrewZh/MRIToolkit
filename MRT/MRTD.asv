% This class implements methods for the MRIToolkit diffusion pipeline
% Differently from other classes (as EDTI), the input / output of this
% class are Niftis and other exchangeble formats (in addition to
% ExploreDTI-compatible .mat files)
classdef MRTD < handle
    methods(Static)
        
        % Create a .MAT from .nii and .bval/.bvec for internal processing
        % in a temporary directory. Input arguments:
        % nii_file: the target .nii file
        % bval_file: the compation .bval fie
        % bvec_file: the companion .bvec file
        % grad_perm: optional, how to permute the diffusion gradients
        % grad_flip: optional, how to flip the sign of the gradients
        function temp_mat_location = QuickNiiBvalBvecToMat(varargin)
            coptions = varargin;
            file_in = GiveValueForName(coptions,'nii_file');
            if(isempty(file_in))
                error('Need to specify the target file');
            end
            
            bval_file = GiveValueForName(coptions,'bval_file');
            if(isempty(bval_file))
                bval_file = [file_in(1:end-4) '.bval'];
            end
            
            bvec_file = GiveValueForName(coptions,'bvec_file');
            if(isempty(bvec_file))
                bvec_file = [file_in(1:end-4) '.bvec'];
            end
            
            option_value = GiveValueForName(coptions,'grad_perm');
            if(~isempty(option_value))
                perm = option_value;
            else
                perm = [];
            end
            option_value = GiveValueForName(coptions,'grad_flip');
            if(~isempty(option_value))
                flip = option_value;
            else
                flip = [];
            end
            
            while(true)
                dest_basename = fullfile(tempdir,['mrtd_' num2str(randi(500000))]);
                if(isempty(dir([dest_basename '*'])))
                    break
                end
            end
            
            EDTI.b_Matrix_from_bval_bvec('bval_file',bval_file,'bvec_file',bvec_file,...
                'output',[dest_basename '.txt']);
            
            if(~isempty(perm) && ~isempty(flip))
                EDTI.PerformDTI_DKIFit('nii_file',file_in,'txt_file',[dest_basename '.txt'],...
                    'output',[dest_basename '.mat'],'grad_perm',perm,'grad_flip',flip);
            else
                EDTI.PerformDTI_DKIFit('nii_file',file_in,'txt_file',[dest_basename '.txt'],...
                    'output',[dest_basename '.mat']);
            end
            
            temp_mat_location = [dest_basename '.mat'];
            
        end
        
        function mkcurve(input_file)
        data = EDTI.EDTI_Data_2_MRIToolkit('mat_file',input_file);
        gradient_info = load(input_file,'b','g','NrB0');
        tensors = load(input_file,'KT','DT','FA');
        siz = size(data.img);
        V = reshape(data.img,siz(1)*siz(2)*siz(3),siz(4));
        V(isnan(tensors.FA(:)),:) = 0;

        tic
        g = [zeros(gradient_info.NrB0,3);gradient_info.g];
        b = gradient_info.b;

        b_kurt = [g(:,1).^4 g(:,2).^4 g(:,3).^4 ...
            4*(g(:,1).^3).*g(:,2) 4*(g(:,1).^3).*g(:,3) ...
            4*(g(:,2).^3).*g(:,1) 4*(g(:,2).^3).*g(:,3) ...
            4*(g(:,3).^3).*g(:,1) 4*(g(:,3).^3).*g(:,2) ...
            6*(g(:,1).^2).*(g(:,2).^2) ...
            6*(g(:,1).^2).*(g(:,3).^2) ...
            6*(g(:,2).^2).*(g(:,3).^2) ...
            12*g(:,2).*g(:,3).*(g(:,1).^2) ...
            12*g(:,1).*g(:,3).*(g(:,2).^2) ...
            12*g(:,1).*g(:,2).*(g(:,3).^2)];

        b_kurt = repmat((1/54)*(b(:,1)+b(:,4)+b(:,6)).^2,[1 15]).*b_kurt;

        b_final = [ones(size(data.img,4),1) -b b_kurt];
        Xd = pinv(b_final);

        K1 = Xd*log(V');
        DT = reshape(K1(2:7,:)',[siz(1:3) 6]);
        KT = reshape(K1(8:end,:)',[siz(1:3) 15]);
        MD = (DT(:,:,:,1)+DT(:,:,:,4)+DT(:,:,:,6))/3;
        KT = KT./((MD*3).^2);

        DT = E_DTI_DWI_mat2cell(DT);
        KT = E_DTI_DWI_mat2cell(KT);

        MK = E_DTI_Mean_Kurtosis(KT,DT);

        A = [g(:,1).^4 g(:,2).^4 g(:,3).^4 ...
            4*(g(:,1).^3).*g(:,2) 4*(g(:,1).^3).*g(:,3) ...
            4*(g(:,2).^3).*g(:,1) 4*(g(:,2).^3).*g(:,3) ...
            4*(g(:,3).^3).*g(:,1) 4*(g(:,3).^3).*g(:,2) ...
            6*(g(:,1).^2).*(g(:,2).^2) ...
            6*(g(:,1).^2).*(g(:,3).^2) ...
            6*(g(:,2).^2).*(g(:,3).^2) ...
            12*g(:,2).*g(:,3).*(g(:,1).^2) ...
            12*g(:,1).*g(:,3).*(g(:,2).^2) ...
            12*g(:,1).*g(:,2).*(g(:,3).^2)];

        B = [g(:,1).^2 g(:,2).^2 g(:,3).^2 2.*g(:,1).*g(:,2) 2.*g(:,1).*g(:,3) 2.*g(:,2).*g(:,3)];

        MK_Q = zeros(size(data.img(:,:,:,1)));
        FA_Q = zeros(size(data.img(:,:,:,1)));
        MD_Q = zeros(size(data.img(:,:,:,1)));
        KA_Q = zeros(size(data.img(:,:,:,1)));
        NEW_S0 = zeros(size(data.img(:,:,:,1)));
        DT_Q = E_DTI_DWI_cell2mat(DT);
        KT_Q = E_DTI_DWI_cell2mat(KT);

        lambda = 0.5;

        S0 = data.img(:,:,:,1);
        min_val = max(S0(:))*0.01;

        for x=1:size(data.img,1)
            for y=1:size(data.img,2)
                for z=1:size(data.img,3)
                %     [x,y,z] = ind2sub(siz(1:3),POINTS2FIX(point_id));
                    So = squeeze(data.img(x,y,z,:));
                    if((So(1) < min_val) || any(~isfinite(So)))
                        continue
                    end
                    s0_val = mean(So(1:gradient_info.NrB0));
                    s0_range = linspace(0.5*s0_val,s0_val*2,100);
                    [~,C_IX] = min(abs(s0_range-s0_val));

                    MK = zeros(length(s0_range),1);

                    for s0_id=1:length(s0_range)

                        S = So;
                        S(1:gradient_info.NrB0) = s0_range(s0_id);

                        GP = S ~= 0;
                        X = Xd(:,GP)*log(S(GP));
                        %     X = b_final\log(S);

                        DT = X(2:7,:);
                        MD = (DT(1)+DT(4)+DT(6))/3;
                        KT = X(8:end,:)./((MD*3).^2);

                        dt = DT([1 4 6 2 3 5]);
                        MDsq = MD^2;

                        for i=gradient_info.NrB0+1:size(g,1)

                            dum_adc = (B(i,:)*dt).^2;
                            dum_kt = A(i,:)*KT;

                            delta = (MDsq.*dum_kt)./dum_adc;
                            if(isnan(delta))
                                disp('Debug');
                                continue
                            end

                            MK(s0_id) = MK(s0_id) + delta;

                        end

                        MK(s0_id) = MK(s0_id)/size(g,1);
                    end

                    last_negative = find(MK<0,1,'last');
                    MKc = MK;
                    MKc(1:last_negative) = NaN;
                    [~,maxmks] = max(MKc);

                    zeromks = find(diff(sign(MK)) ~= 0);
                    if(length(zeromks) > 1)
                        [~,index] = min(abs(s0_range(zeromks)-s0_range(maxmks)));
                        zeromks = zeromks(index);
                    end

                    MK(1:zeromks) = NaN;

                    corr_mk = C_IX;
                    corr_s0 = s0_val;

                    if((~isempty(zeromks) && ~isempty(maxmks)) && zeromks < maxmks)
                        corr_s0 = (1-lambda)*s0_range(zeromks)+lambda*s0_range(maxmks);
                        if(s0_val < corr_s0)
                            [~,corr_mk] = min(abs(s0_range-corr_s0));
                        end
                    end

                    S(1:gradient_info.NrB0) = corr_s0;
                    X = Xd(:,GP)*log(S(GP));
                    %     X = b_final\log(S);

                    DT = X(2:7,:);
                    MD = (DT(1)+DT(4)+DT(6))/3;
                    KT = X(8:end,:)./((MD*3).^2);

                    KT_Q(x,y,z,:) = KT;
                    DT_Q(x,y,z,:) = DT;

                    dt = DT([1 4 6 2 3 5]);
                    MDsq = MD^2;

                    for i=gradient_info.NrB0+1:size(g,1)

                        dum_adc = (B(i,:)*dt).^2;
                        dum_kt = A(i,:)*KT;
                        dum = (MDsq.*dum_kt)./dum_adc(:);

                        MK_Q(x,y,z) = MK_Q(x,y,z) + dum;
                        KA_Q(x,y,z) = KA_Q(x,y,z) + dum^2;
                    end
                    MK_Q(x,y,z) = MK_Q(x,y,z)/size(g,1);    
                    KA_Q(x,y,z) = KA_Q(x,y,z)/size(g,1);    

                    DT = [DT(1) DT(2)/2 DT(3)/2;
                          DT(2)/2 DT(4) DT(5)/2;
                          DT(3)/2 DT(5)/2 DT(6)];
                    [EVEC,EVAL] = eig(DT);
                    EVAL = diag(EVAL);
                    FA_Q(x,y,z) = sqrt(1.5*sum((EVAL-mean(EVAL)).^2)./sum(EVAL.^2));
                    MD_Q(x,y,z) = MD;
                    % figure,plot(data.bvals,S,'.b')
                    % hold on,plot(data.bvals,exp(b_final*X),'-r')
                    % figure, plot(s0_range,MK,'b',[So(1) So(1)],[0 max(abs(MK))],'--r')
                    % hold on
                    % plot([s0_range(zeromks) s0_range(zeromks)],[0 max(abs(MK))],'--b')
                    % plot([s0_range(maxmks) s0_range(maxmks)],[0 max(abs(MK))],'--k')
                    % plot([s0_range(corr_mk) s0_range(corr_mk)],[0 max(abs(MK))],'--g')
                    if(isnan(MK(corr_mk)))
                        MK_Q(x,y,z) = MK(end);
                    end
                    KA_Q(x,y,z) = sqrt(abs(KA_Q(x,y,z)-MK_Q(x,y,z)^2));
                    NEW_S0(x,y,z) = corr_s0;
                end
            end
        end
        toc

        DT = E_DTI_DWI_mat2cell(DT_Q);
        KT = E_DTI_DWI_mat2cell(KT_Q);
        DWIB0 = NEW_S0;
        copyfile(input_file,[input_file(1:end-4) '_mkcurve.mat']);
        save([input_file(1:end-4) '_mkcurve.mat'],'DT','KT','DWIB0','-append');

        end
        
    end
end

% Helper: finds a parameter by name when using varargin
function value = GiveValueForName(coptions,name)
value = [];
for ij=1:2:length(coptions)
    if(strcmpi(coptions{ij},name))
        value = coptions{ij+1};
        return
    end
end
end
